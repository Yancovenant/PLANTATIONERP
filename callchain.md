# Project Structure - Call Chain Documentation

## Quick Start

Run the application using:
```bash
python inphms-bin
# or with configuration parameters
python inphms-bin --<config-params>
```

---

#### Entry Point CLI & Executable Service Installer
- `inphms.cli.main()`
    - if `--addons-path` handle using:
        - `inphms.tools.config._parse_config(args[0])` **@see config.py**
    - `command = "server"` default command
    - if `args` is not starts with `-`, then it is a command, do:
        - `initialize_sys_path()` **@see module.py**
    - `commands[command]().run(args)` creating instance + `.run()`
    - ---
    - continue as `server` command.
    - ---
    - `inphms.cli.server`
        - `run()`:
            - `inphms.tools.config.parser.prog = f'{Path(sys.argv[0]).name} {self.name}'` decorator / cosmetics **@see config.py**
            - `main(args)`:
                - `check_root_user()`
                - `inphms.tools.config.parse_config(args, setup_logging=True)`
                - `check_postgres_user()`:
                    - `config = inphms.tools.config` **@see config.py**
                - `report_configuration()`
                    - `config = inphms.tools.config` **@see config.py**
                - `setup_pid_file()`:
                    - `config = inphms.tools.config` **@see config.py**
                    - at exit, `rm_pid_file(main_pid)`
                - `rc = inphms.service.server.start(preload=preload, stop=stop)`
                    - `load_server_wide_modules()`:
                        - `load_inphms_module(m)` **@see module.py**
                    - ---
                    - continue as `windows/nt` platform
                    - ---
                    - `server = ThreadedServer(inphms.http.root)`
                        - `inphms.http.root = Application()` **@see http.py**
                        - `ThreadedServer.__init__(inphms.http.root)`:
                            - `CommonServer.__init__(app)`:
                                - self.app = app <- inphms.http.root,
                                - self.interface = config['http_interface'] or '0.0.0.0'
                                - self.port = config['http_port']
                                - self.pid = os.getpid()
                            - self.main_thread_id = threading.current_thread().ident
                            - self.quit_signals_received = 0
                            - self.httpd = None
                            - self.limits_reached_threads = set()
                            - self.limit_reached_time = None
                    - `rc = server.run(preload, stop) == ThreadedServer.run()`
                        - `self.start(stop=stop)`:
                            - `set_limit_memory_hard()`
                            - `self.http_spawn()`
                                - ---
                                - Wrapper around werkzeug library
                                - ---
                                - self.httpd = ThreadedWSGIServerReloadable(self.interface, self.port, self.app)
                                    - `ThreadedWSGIServerReloadable(LoggingBaseWSGIServerMixIn, werkzeug.serving.ThreadedWSGIServer):`
                                        - `__init__(self, interface, port, app):`
                                            - self.max_http_threads = os.environ.get("INPHMS_MAX_HTTP_THREADS")
                                            - if self.max_http_threads:
                                                - self.http_threads_sem = threading.Semaphore(self.max_http_threads)
                                            - `super().__init__(host, port, app, handler=RequestHandler)`:
                                                - RequestHandler.protocol_version = "HTTP/1.1" if self.multithread or self.multiprocess
                                                - self.host = host
                                                - self.port = port
                                                - self.app = app
                                                - self.passthrough_errors = passthrough_errors = False (default)
                                                - self.address_family = select_address_family(host, port)
                                                - server_address = get_sockaddr(host, int(port), address_family)
                                                - `super().__init__(server_address, handler, bind_and_activate=False)`
                                                    - `BaseServer.__init__(self, server_address, RequestHandlerClass)`:
                                                        - self.server_address = server_address
                                                        - self.RequestHandlerClass = RequestHandlerClass == RequestHandler
                                                        - self.__is_shut_down = threading.Event()
                                                        - self.__shutdown_request = False
                                                    - self.socket = socket.socket(self.address_family, self.socket_type)
                                                - `self.server_bind()`:
                                                    - ThreadedWSGIServerReloadable.server_bind():
                                                        - self.reload_socket = Bool
                                                        - self.socket, reasign if.
                                                        - super().server_bind()
                                                            - `TCPServer.server_bind():`
                                                                - self.socket.bind(self.server_address)
                                                                - self.server_address = self.socket.getsockname()
                                                            - host, port = self.server_address[:2]
                                                            - self.server_name = socket.getfqdn(host) // fully qualified domain name
                                                            - self.server_port = port
                                                - `self.server_activate()`
                                                    - ThreadedWSGIServerReloadable.server_activate():
                                                        - if not self.reload_socket:
                                                            - super().server_activate()
                                                                - TCPServer.server_activate():
                                                                    - self.socket.listen(self.request_queue_size)
                                                - `Except error`:
                                                    - self.server_close():
                                                        - `super().server_close():`
                                                            - self.socket.close()
                                                        - self._threads.join()
                                                - self.ssl_context = (optional)

                                            - self.daemon_threads = False
                                - threading.Thread(target=self.httpd.serve_forever, name="inphms.service.httpd", daemon=True)
                                    - `self.httpd.serve_forever() == ThreadedWSGIServer.serve_forever()`:
                                        - `super().serve_forever(poll_interval=0.5):`
                                            - `self._handle_request_noblock():`
                                                - if max_http_threads and not self.http_threads_sem.acquire(timeout=0.1):
                                                    - return
                                                - `super()._handle_request_noblock():`
                                                    - `self.get_request()`:
                                                        - self.socket.accept()
                                                    - `self.verify_request(request, client_address)`:
                                                        - Return True
                                                    - TRUE:
                                                        - `self.process_request(request, client_address)`:
                                                            - threading.Thread(target=self.process_request_thread, args=(request, client_address))
                                                                - `self.process_request_thread(request, client_address)`:
                                                                    - `self.finish_request(request, client_address)`:
                                                                        - `self.RequestHandlerClass(request, client_address, self)`
                                                                            - instance of RequestHandler() <- ours.
                                                                            - `RequestHandler.__init__(self, request, client_address, self)`:
                                                                                - self._sent_date_header = None
                                                                                - self._sent_server_header = None
                                                                                - `super().__init__(request, client_address, self)`:
                                                                                    - self.request = request
                                                                                    - self.client_address = client_address
                                                                                    - self.server = server
                                                                                    - `self.setup()`:
                                                                                        - if test_enable or test_file: self.timeout = 5
                                                                                        - `super().setup()`:
                                                                                            - self.connection = self.request
                                                                                            - self.connection.settimeout(self.timeout)
                                                                                            - self.rfile = self.connection.makefile('rb', self.rbufsize)
                                                                                            - if self.wbufsize == 0:
                                                                                                - self.wfile = _SocketWriter(self.connection)
                                                                                            - else:
                                                                                                - self.wfile = self.connection.makefile('wb', self.wbufsize)
                                                                                        - me = threading.current_thread()
                                                                                        - me.name = 'inphms.service.http.request.%s' % (me.ident,)
                                                                                    - `self.handle()`:
                                                                                        - try:
                                                                                            - `super().handle()`:
                                                                                                - self.close_connection = True
                                                                                                - `self.handle_one_request()`:
                                                                                                    - self.raw_requestline = self.rfile.readline(65537)
                                                                                                    - if not `self.parse_request()`:
                                                                                                        - return
                                                                                                    - mname = 'do_' + self.command
                                                                                                    - method = `getattr(self, mname)`
                                                                                                        - `__getattr__`:
                                                                                                            - if name.startswith("do_"):
                                                                                                                - return self.run_wsgi
                                                                                                            - return getattr(super(), name)
                                                                                                    - `method()` == self.run_wsgi():
                                                                                                        - `self.run_wsgi()`:
                                                                                                            - `self.environ = self.make_environ()`:
                                                                                                                - environ = `super().make_environ()`:
                                                                                                                    - return environ
                                                                                                                - environ['socket'] = self.connection
                                                                                                                - if self.headers.get('Upgrade') == 'websocket':
                                                                                                                    - self.protocol_version = "HTTP/1.1"
                                                                                                                - return environ
                                                                                                            - try:
                                                                                                                - `execute(self.server.app)`:
                                                                                                                    - `self.server.app(self.environ, self.start_response)` == inphms.http.root == Application(self.environ, self.start_response)
                                                                                                                        - `Application.__call__(environ, start_response)`: // because its being called, init already before.
                                                                                                                            - del current_thread.dbname
                                                                                                                            - del current_thread.uid
                                                                                                                            - with HTTPRequest(environ) as httprequest:
                                                                                                                                - `HTTPRequest.__init__(self, environ)`:
                                                                                                                                    - httprequest = werkzeug.wrappers.Request(environ) <- werkzeug library, wrapping.
                                                                                                                                    - self._session_id__ = httprequest.cookies.get('session_id')
                                                                                                                                    - self.__wrapped = httprequest
                                                                                                                                    - self.__environ = self.__wrapped.environ
                                                                                                                                    - ```python
                                                                                                                                        self.environ = self.headers.environ = {
                                                                                                                                            key: value
                                                                                                                                            for key, value in self.__environ.items()
                                                                                                                                            if (not key.startswith(('werkzeug.', 'wsgi.', 'socket')) or key in ['wsgi.url_scheme', 'werkzeug.proxy_fix.orig'])
                                                                                                                                        }
                                                                                                                                      ```
                                                                                                                                - ```markdown
                                                                                                                                    HTTPRequest.attributes = [
                                                                                                                                        ...HTTPREQUEST_ATTRIBUTES, each wrapped into property,
                                                                                                                                        get, set,
                                                                                                                                        into self.__wrapped.__attr__
                                                                                                                                    ]
                                                                                                                                  ```
                                                                                                                                - request = `Request(httprequest)`:
                                                                                                                                    - `Request.__init__(self, httprequest)`:
                                                                                                                                        - self.httprequest = httprequest
                                                                                                                                        - self.dispatcher = _dispatchers['http'](self)
                                                                                                                                        - self.params = {}
                                                                                                                                        - self.registry = None
                                                                                                                                        - self.env = None
                                                                                                                                - _request_stack.push(request)
                                                                                                                                - try:
                                                                                                                                    - `request._post_init()`:
                                                                                                                                        - self.session, self.db = `self._get_session_and_dbname()`:
                                                                                                                                            - `self._get_session_and_dbname()`:
                                                                                                                                                - sid = self.httprequest._session_id__
                                                                                                                                                - if not sid or not `root.session_store.is_valid_key(sid)`:
                                                                                                                                                    - `root.session_store <--> .is_valid_key(sid)`:
                                                                                                                                                        - return `FilesystemSessionStore(inphms.tools.config.session_dir, session_class=Session, renew_missing=True)`
                                                                                                                                                            - `FilesystemSessionStore.__init__(self, path, session_class=Session, renew_missing=True)`:
                                                                                                                                                                - `SessionStore.__init__(self, session_class=Session)`:
                                                                                                                                                                    - self.session_class = session_class or Session <- default.
                                                                                                                                                                - self.path = path or tempfile.gettempdir()
                                                                                                                                                                - self.renew_missing = renew_missing
                                                                                                                                                                - self.mode = mode
                                                                                                                                                            - `.is_valid_key(sid)`:
                                                                                                                                                                - return `_base64_urlsafe_re.match(key) is not None`
                                                                                                                                                        - `root.session_store.new()`:
                                                                                                                                                            - `FilesystemSessionStore.new()`:
                                                                                                                                                                - return `self.session_class({}, self.generate_key(), True)`:
                                                                                                                                                                    - `self.generate_key()`:
                                                                                                                                                                        - return base64.urlsafe_b64encode(sha512(str(time.time() + os.urandom(64)).encode()).digest()[:-1]).decode('utf-8')
                                                                                                                                                                    - `Session.__init__(self, data, sid, new=True)`:
                                                                                                                                                                        - self.can_save = True
                                                                                                                                                                        - self.__data = {}
                                                                                                                                                                        - self.update(data)
                                                                                                                                                                        - self.is_dirty = False
                                                                                                                                                                        - self.is_new = new
                                                                                                                                                                        - self.should_rotate = False
                                                                                                                                                                        - self.sid = sid
                                                                                                                                                - else #`root.session_store.get(sid) -- root.session_store == FilesystemSessionStore`:
                                                                                                                                                    - `FilesystemSessionStore.get(sid)`:
                                                                                                                                                        - - NOT DONE
                                                                                                                                                    - session.sid = sid
                                                                                                                                                - session -- setdefault() attr. + default_lang == self.default_lang()
                                                                                                                                                - if session.db and `db_filter([session.db], host=host)`:
                                                                                                                                                    - `db_filter(dbs, host=host or None)`:
                                                                                                                                                        - if config['dbfilter']:
                                                                                                                                                            - return [db for db in dbs if dbfilter_re.match(db)]
                                                                                                                                                        - if config['db_name']:
                                                                                                                                                            - exposed_dbs = {db.strip() for db in config['db_name'].split(',')}
                                                                                                                                                            - return sorted(exposed_dbs.intersection(dbs))
                                                                                                                                                        - return list(dbs)
                                                                                                                                                - else `all_dbs = db_list(force=True, host=host)`:
                                                                                                                                                    - `db_list(force=force or False, host=host or None)`:
                                                                                                                                                        - try:
                                                                                                                                                            - `dbs = inphms.service.db.list_dbs(force)` @see db.py
                                                                                                                                                            - except psycopg2.OperationalError:
                                                                                                                                                                - return []
                                                                                                                                                            - return `db_filter(dbs, host)`
                                                                                                                                                - if session.db != dbname:
                                                                                                                                                    - if session.db: `session.logout(keep_db=False)`:
                                                                                                                                                        - `session.logout(keep_db=keep_db or False)`:
                                                                                                                                                            - db = self.db if keep_db or `get_default_session()['db']`:
                                                                                                                                                                - `get_default_session()['db']`:
                                                                                                                                                                    - return None
                                                                                                                                                            - `self.clear()`:
                                                                                                                                                                - `self.__data.clear()` <- clear everything inside dict.
                                                                                                                                                                - self.is_dirty = True
                                                                                                                                                            - self.update(get_default_session(), db=db, debug=debug) # None
                                                                                                                                                            - self.context['lang'] = request.default_lang() if request else DEFAULT_LANG
                                                                                                                                                            - self.should_rotate = True
                                                                                                                                                            - if request and `request.env`:
                                                                                                                                                                - `request.env['ir.http']._post_logout()`:
                                                                                                                                                                    - not done
                                                                                                                                                    - session.db = dbname
                                                                                                                                                - session.is_dirty = False
                                                                                                                                                - Return session, dbname
                                                                                                                                        - self._post_init = None
                                                                                                                                    - if `self.get_static_file(self.httprequest.path)`:
                                                                                                                                        - `self.get_static_file(url, host='')`:
                                                                                                                                            - return `file_path(f'{module}/static/{resource}')` @see misc.py or None
                                                                                                                                    - elif `request.db`:
                                                                                                                                        - with `request._get_profiler_context_manager()`:
                                                                                                                                            - ---
                                                                                                                                            - Profiller area starts here.
                                                                                                                                            - ---
                                                                                                                                            - `request._get_profiler_context_manager()`:
                                                                                                                                                - if self.session.profile_session and self.db:
                                                                                                                                                    - return profiler.Profiler(
                                                                                                                                                        db=self.db,
                                                                                                                                                        description=self.httprequest.full_path,
                                                                                                                                                        profile_session=self.session.profile_session,
                                                                                                                                                        collectors=self.session.profile_collectors,
                                                                                                                                                        params=self.session.profile_params,
                                                                                                                                                    )._get_cm_proxy()
                                                                                                                                                    - `Profiler.__init__(self, db=db, description=description, profile_session=profile_session, collectors=collectors, params=params)`:
                                                                                                                                                        - self.start_time = 0
                                                                                                                                                        - self.duration = 0
                                                                                                                                                        - self.profile_session = profile_session or profiler.make_session()
                                                                                                                                                        - self.description = description
                                                                                                                                                        - self.init_frame = None
                                                                                                                                                        - self.init_stack_trace = None
                                                                                                                                                        - self.init_thread = None
                                                                                                                                                        - self.disable_gc = disable_gc
                                                                                                                                                        - self.filecache = {}
                                                                                                                                                        - self.params = params or {}  # custom parameters usable by collectors
                                                                                                                                                        - self.profile_id = None
                                                                                                                                                        - self.log = log
                                                                                                                                                        - self.sub_profilers = []
                                                                                                                                                        - self.entry_count_limit = int(self.params.get("entry_count_limit", 0))   # the limit could be set using a smarter way
                                                                                                                                                        - self.done = False
                                                                                                                                                        - if db is ...:
                                                                                                                                                            - db = getattr(threading.current_thread(), 'dbname', None)
                                                                                                                                                            - if not db:
                                                                                                                                                                - raise Exception('Database name cannot be defined automaticaly. \n Please provide a valid/falsy dbname or path parameter')
                                                                                                                                                        - self.db = db
                                                                                                                                                        - if collectors is None:
                                                                                                                                                            - collectors = ['sql', 'traces_async']
                                                                                                                                                        - self.collectors = []
                                                                                                                                                        - for collector in collectors:
                                                                                                                                                            - if isinstance(collector, str):
                                                                                                                                                                - try:
                                                                                                                                                                    - collector = Collector.make(collector)
                                                                                                                                                                    - `Collector.make(collector)`:
                                                                                                                                                                        - ////
                                                                                                                                                                - Except Exception:
                                                                                                                                                                    - continue
                                                                                                                                                            - collector.profiler = self
                                                                                                                                                            - self.collectors.append(collector)
                                                                                                                                                - else:
                                                                                                                                                    - return contextlib.nullcontext() # stand-in for a context manager that does nothing
                                                                                                                                            - ---
                                                                                                                                            - Profiller area ends here.
                                                                                                                                            - ---
                                                                                                                                            - `response = request._serve_db()`:
                                                                                                                                                - `request._serve_db()`:
                                                                                                                                                    - `self.registry, cr_readwrite = self._open_registry()`:
                                                                                                                                                        - `self._open_registry()`:
                                                                                                                                                            - `Registry(self.db)` @see registry.py
                                                                                                                                                            - `registry.cursor(readonly=False)` @see registry.py
                                                                                                                                                            - `registry.check_signaling(cr_readwrite)` @see registry.py
                                                                                                                                                            - return registry, cr_readwrite
                                                                                                                                                    - threading.current_thread().dbname = self.registry.db_name
                                                                                                                                                    - self.env = inphms.api.Environment(cr_readwrite, self.session.uid, self.session.context)
                                                                                                                                                        - `inphms.api.Environment(cr_readwrite, self.session.uid, self.session.context)`:
                                                                                                                                                            - not done
                                                                                                                                                    - try:
                                                                                                                                                        - rule, args = self.registry['ir.http']._match(self.httprequest.path)
                                                                                                                                                    - except NotFound:
                                                                                                                                                        - not_found = NotFound
                                                                                                                                                    - finally:
                                                                                                                                                        - if cr_readwrite is not None:
                                                                                                                                                            - cr_readwrite.close()
                                                                                                                                                    - if not_found:
                                                                                                                                                        - return self._transactioning(
                                                                                                                                                            functools.partial(self._serve_ir_http_fallback, not_found),
                                                                                                                                                            readonly=True,
                                                                                                                                                        )
                                                                                                                                                        - `self._transactioning(functools.partial(self._serve_ir_http_fallback, not_found), readonly=True)`:
                                                                                                                                                            - `self._serve_ir_http_fallback(not_found)`:
                                                                                                                                                                - `self.params = self.get_http_params()`:
                                                                                                                                                                    - `self.get_http_params()`:
                                                                                                                                                                        - return {
                                                                                                                                                                            **self.httprequest.args,
                                                                                                                                                                            **self.httprequest.form,
                                                                                                                                                                            **self.httprequest.files
                                                                                                                                                                        }
                                                                                                                                                                - response = `self.registry['ir.http']._serve_fallback()`:
                                                                                                                                                                    - `self.registry['ir.http']._serve_fallback()`:
                                                                                                                                                                        - not done
                                                                                                                                                                - if response:
                                                                                                                                                                    - `self.registry['ir.http']._post_dispatch(response)`:
                                                                                                                                                                        - not done
                                                                                                                                                                    return response
                                                                                                                                                                - no_fallback = NotFound()
                                                                                                                                                                - no_fallback.__context__ = not_found
                                                                                                                                                                - no_fallback.error_response = `self.registry['ir.http']._handle_error(no_fallback)`
                                                                                                                                                                    - `self.registry['ir.http']._handle_error(no_fallback)`:
                                                                                                                                                                        - not done
                                                                                                                                                                - raise no_fallback
                                                                                                                                                            - `self._transactioning(functools.partial(self._serve_ir_http_fallback, not_found), readonly=True)`:
                                                                                                                                                                - for readonly_cr in (True, False) if readonly else (False,):
                                                                                                                                                                    - threading.current_thread().cursor_mode = (
                                                                                                                                                                        'ro' if readonly_cr
                                                                                                                                                                        else 'ro->rw' if readonly
                                                                                                                                                                        else 'rw'
                                                                                                                                                                    )
                                                                                                                                                                    - with contextlib.closing(self.registry.cursor(readonly=readonly_cr)) as cr:
                                                                                                                                                                        - `self.registry.cursor(readonly=readonly_cr)` @see registry.py
                                                                                                                                                                        - `self.env = self.env(cr=cr)`:
                                                                                                                                                                            - inphms.api.Environment(cr=cr) @see api.py
                                                                                                                                                                        - try:
                                                                                                                                                                            - return `service_model.retrying(func, env=self.env)`:
                                                                                                                                                                                - result from func() @see model.py
                                                                                                                                                                        - Except psycopg2.errors.ReadOnlySqlTransaction as exc:
                                                                                                                                                                            - continue
                                                                                                                                                                        - Except Exception as exc:
                                                                                                                                                                            - `raise`
                                                                                                                                                    - `self._set_request_dispatcher(rule)`:
                                                                                                                                                        - routing = rule.endpoint.routing
                                                                                                                                                        - 
                                                                                                                                                    - readonly = rule.endpoint.routing['readonly']
                                                                                                                                                    - if callable(readonly):
                                                                                                                                        - Except RegistryError as e:
                                                                                                                                            - `request.session.logout()`:
                                                                                                                                            - if (self.httprequest.path.startswith('/inphms/') or self.httprequest.path in ('/inphms', '/web', '/web/login', '/test_http/ensure_db')):
                                                                                                                                                - `request.reroute(self.httprequest.path, url_encode(self.httprequest.args.copy().pop('db', None)))`
                                                                                                                                            - `response = request._serve_nodb()`:
                                                                                                                                                - router = `root.nodb_routing_map.bind_to_environ(self.httprequest.environ)`:
                                                                                                                                                    - `root.nodb_routing_map()`:
                                                                                                                                                        - nodb_routing_map = werkzeug.routing.Map(strict_slashes=False, converters=None)
                                                                                                                                                        - for url, endpoint in _generate_routing_rules([''] + inphms.conf.server_wide_modules, nodb_only=True):
                                                                                                                                                            - `_generate_routing_rules([''] + inphms.conf.server_wide_modules, nodb_only=True)`:
                                                                                                                                                                - `inphms.conf.server_wide_modules`: base, web
                                                                                                                                                                - for ctrl in `build_controllers()`:
                                                                                                                                                                    - `build_controllers()`:
                                                                                                                                                                        - yield from (ctrl() for ctrl in Controller.children_classes.get('', []))
                                                                                                                                                                        - highest_controllers = []
                                                                                                                                                                        - for module in modules:
                                                                                                                                                                            - highest_controllers.extend(Controller.children_classes.get(module, []))
                                                                                                                                                                        - for top_ctrl in highest_controllers:
                                                                                                                                                                            - leaf_controllers = `list(unique(get_leaf_classes(top_ctrl)))`:
                                                                                                                                                                                - `unique(it : Iterable[T]) -> Iterator[T]`:
                                                                                                                                                                                    - yield from unique(it)
                                                                                                                                                                                - `get_leaf_classes(top_ctrl)`:
                                                                                                                                                                                    - cls.__subclasses__()
                                                                                                                                                                                    - is_valid(subcls)
                                                                                                                                                                                    - loop back to `get_leaf_classes(top_ctrl)`
                                                                                                                                                                                    - result.append(cls)
                                                                                                                                                                                    - return result
                                                                                                                                                                                - leaf_controllers = list [] type object.
                                                                                                                                                                            - extend name of children controller classes
                                                                                                                                                                            - Ctrl = type(name, tuple(reversed(leaf_controllers)), {})
                                                                                                                                                                            - yield Ctrl()
                                                                                                                                                                    - for method_name, method in inspect.getmembers(ctrl, inspect.ismethod):
                                                                                                                                                                        - if not any(map(is_method_a_route, type(ctrl).mro())):
                                                                                                                                                                            - `is_method_a_route(cls)`:
                                                                                                                                                                                - return getattr(getattr(cls, method_name, None), 'original_routing', None) is not None
                                                                                                                                                                                - `original_routing` -> from def route() method decorator wrapper.
                                                                                                                                                                            - merged_routing = {
                                                                                                                                                                                - 'type': 'http',  # set below
                                                                                                                                                                                - 'auth': 'user',
                                                                                                                                                                                - 'methods': None,
                                                                                                                                                                                - 'routes': [],
                                                                                                                                                                            }
                                                                                                                                                                            - for cls in unique(reversed(type(ctrl).mro()[:-2])):
                                                                                                                                                                                - if method_name not in cls.__dict__:
                                                                                                                                                                                    - continue
                                                                                                                                                                                - submethod = getattr(cls, method_name)
                                                                                                                                                                                - if not hasattr(submethod, 'original_routing'):
                                                                                                                                                                                    - submethod = route()(submethod)
                                                                                                                                                                                - _check_and_complete_route_definition(cls, submethod, merged_routing)
                                                                                                                                                                                    - `_check_and_complete_route_definition(cls, submethod, merged_routing)`:
                                                                                                                                                                                        - setdefault/force/ and warn.
                                                                                                                                                                                - merged_routing.update(submethod.original_routing)
                                                                                                                                                                            - if not merged_routing['routes']: continue
                                                                                                                                                                            - if nodb_only and merged_routing['auth'] != "none": continue // only setup for nodb + doesn't require auth. for the server startup.
                                                                                                                                                                            - for url in merged_routing['routes']:
                                                                                                                                                                                - endpoint = functools.partial(method) // copy
                                                                                                                                                                                - functools.update_wrapper(endpoint, method) // wrapped
                                                                                                                                                                                - endpoint.routing = merged_routing // updated
                                                                                                                                                                                - yield (url, endpoint) // return
                                                                                                                                                            - routing = submap(endpoint.routing, ROUTING_KEYS)
                                                                                                                                                                - `submap(routing, ROUTING_KEYS)`:
                                                                                                                                                                    - return filtered dict from the original keys {K:v}.
                                                                                                                                                                - ROUTING_KEYS == werkzeug understandable keys.
                                                                                                                                                            - rule = werkzeug.routing.Rule(url, endpoint=endpoint, **routing)
                                                                                                                                                            - add `OPTIONS` if not in `methods`
                                                                                                                                                            - rule.merge_slashes = False
                                                                                                                                                            - nodb_routing_map.add(rule)
                                                                                                                                                        - return nodb_routing_map
                                                                                                                                                    - `.bind_to_environ(self.httprequest.environ)` @see werkzeug.routing.map.py
                                                                                                                                                        - NOT DONE
                                                                                                                                                - rule, args = router.match(return_rule=True)
                                                                                                                                                - self._set_request_dispatcher(rule)
                                                                                                                                                    - `_set_request_dispatcher(rule)`:
                                                                                                                                                        - routing = rule.endpoint.routing
                                                                                                                                                        - dispatcher_cls = _dispatchers[routing['type']]
                                                                                                                                                        - if 1. not `is_cors_preflight(self, rule.endpoint)`:
                                                                                                                                                            - return if method == 'OPTIONS' and endpoint.routing.get('cors', False)
                                                                                                                                                        - if 2. not `dispatcher_cls.is_compatible_with(self)`:
                                                                                                                                                            - ---
                                                                                                                                                            - HTTP dispatcher Example
                                                                                                                                                            - ---
                                                                                                                                                            - return True.
                                                                                                                                                        - if all this: 
                                                                                                                                                            - raise BadRequest(f"Request inferred type is compatible with {compatible_dispatchers} but {routing['routes'][0]!r} is type={routing['type']!r}.")
                                                                                                                                                        - self.dispatcher = dispatcher_cls(self)
                                                                                                                                                - self.`dispatcher.pre_dispatch(rule, args):`
                                                                                                                                                    - routing = rule.endpoint.routing
                                                                                                                                                    - self.request.session.can_save = routing.get('save_session', True)
                                                                                                                                                    - set_header = self.request.`future_response.headers.set` @see werkzeug.datastructures.Headers.set method.
                                                                                                                                                    - set header for CORS.
                                                                                                                                                    - set header for CORS and OPTIONS method.
                                                                                                                                                    - set header for max content length.
                                                                                                                                                - response = self.`dispatcher.dispatch(rule.endpoint, args)`:
                                                                                                                                                    - self.request.params = dict(self.request.get_http_params(), **args) // merged.
                                                                                                                                                    - if method NOT IN CSRF_FREE_METHODS and endpoint.routing.get('csrf', True):
                                                                                                                                                        - if not self.request.db:
                                                                                                                                                            - return self.request.redirect('/web/database/selector')
                                                                                                                                                        - token = self.request.params.pop('csrf_token', None)
                                                                                                                                                        - if not self.request.`validate_csrf(token)`:
                                                                                                                                                            - hm, _, max_ts = csrf.rpartition('o')
                                                                                                                                                            - token expiry check
                                                                                                                                                            - token validation check.
                                                                                                                                                        - if False: would check:
                                                                                                                                                            - if its missing or failed validation.
                                                                                                                                                    - if self.request.db:
                                                                                                                                                        - return `self.request.registry['ir.http']._dispatch(endpoint)` @see registry.py
                                                                                                                                                    - else:
                                                                                                                                                        - return endpoint(**self.request.params)
                                                                                                                                                - `self.dispatcher.post_dispatch(response)`:
                                                                                                                                                    - `self.request._save_session()`:
                                                                                                                                                        - if sess.`should_rotate`:
                                                                                                                                                            - `root.session_store.rotate(sess, self.env)`:
                                                                                                                                                                - delete
                                                                                                                                                                - generate
                                                                                                                                                                - save
                                                                                                                                                        - if sess.is_dirty:
                                                                                                                                                            - save
                                                                                                                                                        - cookie_sid = self.cookies.get('session_id')
                                                                                                                                                        - if sess.is_dirty or cookie_sid != sess.sid:
                                                                                                                                                            - set_cookie
                                                                                                                                                    - `self.request._inject_future_response(response)`:
                                                                                                                                                        - response.headers.extend(self.future_response.headers)
                                                                                                                                                    - `root.set_csp(response)`:
                                                                                                                                                        - set content security policy headers.
                                                                                                                                                - return response
                                                                                                                                    - else:
                                                                                                                                        - `response = request._serve_nodb()`:
                                                                                                                                    - return `response(environ, start_response)`
                                                                                                                                - Except Exception:
                                                                                                                                    - log, response.
                                                                                                                                    - `dispatch.handle_error(exc)`:
                                                                                                                                        - session.logout(keep_db=True)
                                                                                                                                        - response = self.request.redirect_query('/web/login', {'redirect': self.request.httprequest.full_path})
                                                                                                                                        - if was_connected:
                                                                                                                                            - `root.session_store.rotate(session, self.request.env)`:
                                                                                                                                                - delete
                                                                                                                                                - generate
                                                                                                                                                - save
                                                                                                                                        - response.set_cookie('session_id', session.sid, max_age=get_session_max_inactivity(self.env), httponly=True)
                                                                                                                                        - return response
                                                                                                                                - Finally:
                                                                                                                                    - `_request_stack.pop()`
                                                                                                            - Except Exception:
                                                                                                                - `self.connection_dropped(e, self.environ)`
                                                                                                            - Except:
                                                                                                                - `execute(InternalServerError())`
                                                                                                    - self.wfile.flush()
                                                                                                - while not self.close_connection:
                                                                                                    - self.handle_one_request()
                                                                                        - Except Exception:
                                                                                            - self.connection_dropped(e)
                                                                                        - Except:
                                                                                            - if self.server.ssl_context is not None and is_ssl_error(e):
                                                                                                - `self.log_error("SSL error occurred: %s", e)`
                                                                                            - else:
                                                                                                - raise
                                                                                    - `self.finish()`:
                                                                    - Except Exception:
                                                                        - `self.handle_error(request, client_address)`
                                                                    - Finally:
                                                                        - `self.shutdown_request(request)`
                                                        - Except Exception:
                                                            - `self.handle_error(request, client_address)`
                                                            - self.shutdown_request(request)
                                                        - Except:
                                                            - self.shutdown_request(request)
                                                            - raise
                                                    - ELSE:
                                                        - `self.shutdown_request(request)`:
                                            - `self.service_actions()`
                                        - `finnaly: self.server_close()`
                            - `self.cron_spawn():`
                                - threading.Thread(target=self.cron_thread(i), name="inphms.service.cron.cron%d" % i)
                                - `self.cron_thread(i)`:
                                    - `inphms.sql_db.db_connect('postgres')`
                                    - `with contextlib.closing(conn.cursor()) as cr:`
                                        - `_run_cron(cr):`
                                            - cr.execute() @see sql_db.py
                                            - cr.commit() @see sql_db.py
                                            - cr._cnx.poll() @see sql_db.py
                                            - `registries = inphms.modules.registry.Registry.registries` @see registry.py
                                            - `ir_cron._process_jobs(db_name)` @see inphms/addons/base/models/ir_cron.py
                                        - `cr._cnx.close()` @see sql_db.py


#### CONFIG Entry Point
- `config = configmanager() == inphms.tools.config`

#### ORM Entry Point
- `load_server_wide_modules()`:
    - `load_inphms_module(m)`:
        - `__import__(qualname)`:
            - What happens here is that it would import anything inside inphms.addons.__path__
            - Especially the models folders. (ORM/MODEL Entry Point)
            - ---
            - CONTINUE AS inphms.addons.base
            - ---
            - `__new__` is being called
            - `class ir_cron(models.Model)`:
                - _name = 'ir.cron'
                - _order = 'cron_name'
                - _description = 'Scheduled Actions'
                - _allow_sudo_commands = False
                - _sql_constraints = 
                    ```python
                        [
                            (
                                'check_strictly_positive_interval',
                                'CHECK(interval_number > 0)',
                                'The interval number must be a strictly positive number.'
                            ),
                        ]
                    ```
                - `models.Model(AbstractModel)`:
                    - _auto = True
                    - _register = False
                    - _abstract = False
                    - _transient = False
                    - `models.AbstractModel == BaseModel(metaclass=MetaModel)`:
                        - __slots__ = ['env', '_ids', '_prefetch_ids']
                        - env: api.Environment
                        - id: IdType | typing.Literal[False]
                        - display_name: str | typing.Literal[False]
                        - pool: Registry
                        - _fields: dict[str, Field]
                        - _module = None
                        - _custom = False
                        - _inherit: str | list[str] | tuple[str, ...] = ()
                        - _inherits = frozendict()
                        - _table = None
                        - _table_query = None
                        - _sql_constraints: list[tuple[str, str, str]] = []
                        - _rec_name = None
                        - _rec_names_search: list[str] | None = None
                        - _order = 'id'
                        - _parent_name = 'parent_id'
                        - _parent_store = False
                        - _active_name = None
                        - _fold_name = 'fold'
                        - _translate = True
                        - _check_company_auto = False
                        - _depends = frozendict()
                        - _transient_max_count = lazy_classproperty(lambda _: config.get('osv_memory_count_limit'))
                        - _transient_max_hours = lazy_classproperty(lambda _: config.get('transient_age_limit'))
                    - `metaclass=MetaModel`:
                        - 